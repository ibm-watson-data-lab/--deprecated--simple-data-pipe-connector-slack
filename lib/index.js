//-------------------------------------------------------------------------------
// Copyright IBM Corp. 2015
//
// Licensed under the Apache License, Version 2.0 (the 'License');
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//-------------------------------------------------------------------------------

'use strict';

var util = require('util');
var _ = require('lodash');
var async = require('async');

var pipesSDK = require('simple-data-pipe-sdk');
var connectorExt = pipesSDK.connectorExt;

var bluemixHelperConfig = require('bluemix-helper-config');
var global = bluemixHelperConfig.global;

// Use https://www.npmjs.com/package/passport-slack strategy to complete OAuth flow
var dataSourcePassportStrategy = require('passport-slack').Strategy; 

// Pick your favorite Slack API library to fetch data, e.g. https://www.npmjs.com/package/slack-node
var Slack = require('slack-node');

/**
 * Slack OAuth connector that stores a few JSON records in Cloudant
 * Build your own connector by following the TODO instructions
 */
function oAuthSlackConnector( parentDirPath ){

	//   Replace 'Slack OAuth Data Source' with the desired display name of the data source (e.g. a specific slack domain) from which data will be loaded
	var connectorInfo = {
						  id: require('../package.json').simple_data_pipe.name,			// derive internal connector ID from package.json
						  name: 'Slack'													// TODO; change connector display name
						};

	// TODO: customize options						
	var connectorOptions = {
					  		recreateTargetDb: true, // if set (default: false) all data currently stored in the staging database is removed prior to data load
					  		useCustomTables: true   // keep true (default: false)
						   };						

	// Call constructor from super class; 
	connectorExt.call(this, 
					 connectorInfo.id, 			
					 connectorInfo.name, 
					 connectorOptions	  
					 );	

	// writes to the application's global log file
	var globalLog = this.globalLog;

    // Slack API library handle
	var slack = null;

	/**
	 * Customization is mandatory!
	 * Define the passport strategy to use for oAuth authentication with the data source
	 * @param pipe - data pipe configuration, containing the user-provided oAuth client id and client secret
	 * @returns a passport strategy for this data source
	 */
	this.getPassportStrategy = function(pipe) {

		// Use https://github.com/mjpearson/passport-slack strategy
		return new dataSourcePassportStrategy({
			clientID: pipe.clientId,											 // mandatory; oAuth client id; do not change
	        clientSecret: pipe.clientSecret,									 // mandatory; oAuth client secret;do not change
	        callbackURL: global.getHostUrl() + '/authCallback',		 			 // mandatory; oAuth callback; do not change
	        skipUserProfile: true												 // disable user profile loading
		  },
		  function(accessToken, refreshToken, profile, done) {					 // Passport verify callback; customize signature as needed

			  process.nextTick(function () {

			  	globalLog.debug('User was authenticated successfully. Profile information: ' + util.inspect(profile,3));

			  	// if scope "users:read" wasn't requested no profile information is returned
			  	// create a dummy to which we can attach the oAuth information 
			  	profile = profile || {};

			  	// Mandatory; attach the obtained access token to the user profile
			  	// Mandatory, if applicable; also attach the obtained refresh token to the user profile
			  	// the user profile is passed as a parameter to authCallback() that passportAuthCallbackPostProcessing
			  	// is expecting
		        profile.oauth_access_token = accessToken; 		        
		        profile.oauth_refresh_token = refreshToken; 

			    return done(null, profile);
			  });
		  }
		);
	};

	/**
	 * Customization is mandatory!	
	 * Returns list of data source specific OAuth options to be passed to the passport.authenticate call,
	 * which starts the OAuth flow.
	 * @override
	 * @returns {} 
	 */
	this.getPassportAuthorizationParams = function() {
       // ensure that the utilized API calls are covered by the requested OAuth scope (https://api.slack.com/docs/oauth-scopes)		
       return {scope: 'channels:read channels:history'};
	}; // getPassportAuthorizationParams

	/**
	 * Customization is mandatory!	
	 * passportAuthCallbackPostProcessing: post processing for OAuth authentication protocol
	 * Stores accessToken + refreshToken and retrieves list of available data sets that can be moved by the pipe
	 * @param profile - the output generated by the passport verify callback
	 * @param pipe - data pipe configuration
	 * @param callback(err, pipe ) error information in case of a problem or the updated pipe
	 */
	this.passportAuthCallbackPostProcessing = function( profile, pipe, callback ){
				
        // TODO: attach the token(s) and other relevant information from the profile to the pipe configuration
        //       use this information in the connector code to access the data source

		pipe.oAuth = { 
						accessToken : profile.oauth_access_token, 
						refreshToken: profile.oauth_refresh_token 
					};

		// Fetch list of data sets that the user can choose from; the list is displayed in the Web UI in the "Filter Data" panel.
        // Attach data set list to the pipe configuration
		getSlackDataSetList(pipe, function (err, updated_pipe){
			if(err) {
		    	globalLog.error('OAuth post processing failed. The Slack data set list could not be created for data pipe configuration ' + pipe._id + ': ' + err);
		    }	
		    else {
			    globalLog.debug('OAuth post processing completed. Data pipe configuration was updated: ');
			    globalLog.debug(' ' + util.inspect(updated_pipe,3));
		    }	

			return callback(err, updated_pipe);
		});			

	}; // authCallback

	/*
	 * Customization is mandatory!
	 * Helper method assembles list of public Slack channels that can be processed by this data pipe.
	 * @param {Object} pipe - Data pipe configuration
	 * @param {callback} done - invoke after processing is complete or has resulted in an error; parameters (err, updated_pipe_configuration)
	 * @return {Object} updated_pipe_configuration - Updated data pipe configuration, containing the mandatory property "tables", identifying which data sets a 
	 * user can choose from when fetching data from Slack
	 */
	var getSlackDataSetList = function(pipe, done){

		var dataSets = [];

		globalLog.info('Assembling public Slack channel list.');

		// initialize slack API
		initializeSlackAPI(pipe, function (err) {

			if(err) {
				globalLog.error('List of public channels could not be retrieved from Slack: ' + err);
				return done(err);
			}

			// fetch list of public channels (https://api.slack.com/methods/channels.list), including archived channels
			slack.api('channels.list', function(err, response){

				if(err) {
					globalLog.error('List of public channels could not be retrieved from Slack: ' + err);
					return done('List of public channels could not be retrieved from Slack: ' + err);
				}

				if((!response) || (! response.ok)) {
					globalLog.error('List of public channels could not be retrieved from Slack: Check the log file for details.');
					globalLog.error('FFDC: Slack respose for channels.list request: ' + util.inspect(response,3));
					return done('List of public channels could not be retrieved from Slack: Check the log file for details.');					
				}

				globalLog.debug('Slack response to channels.list request: ' + util.inspect(response,3));

				_.forEach(response.channels, function(channel) {

					if(channel.is_archived) {
						dataSets.push({name: channel.id, label: channel.name + ' (archived)', description: channel.topic.value}); 	
					}		
					else {
						dataSets.push({name: channel.id, label: channel.name, description: channel.topic.value}); 	
					}
					
				});

				// Sometimes you might want to provide the user with the option to load all data sets concurrently
				// To enable that feature, define a single data set that contains only property 'labelPlural' 
				dataSets.push({labelPlural:'All channels'});				

				// In the UI the user gets to choose from: 
				//  -> All channels
				//  -> channel 1
				//  -> ...

				// sort data set list (if present, the ALL_DATA option should be displayed first)
				// attach data set list to data pipe configuration document
				pipe.tables =  dataSets.sort(function (dataSet1, dataSet2) {
																			if(! dataSet1.name)	{ // ALL_DATA (only property labelPlural is defined)
																				return -1;
																			}

																			if(! dataSet2.name) {// ALL_DATA (only property labelPlural is defined)
																				return 1;
																			}

																			return dataSet1.label.localeCompare(dataSet2.label);
																	   });

				globalLog.info(pipe.tables.length + ' data sets are available for processing.');

				return done(null, pipe);

			}); // slack.api('channels.list'
		}); // initializeSlackAPI(

	}; // method getSlackDataSetList

   /*
	* ---------------------------------------------------------------------------------------
	* Override general connector methods:
	*  - doConnectStep: verify that OAuth information is still valid
	*  - fetchRecords:  load data from data source
	* ---------------------------------------------------------------------------------------
	*/

   /**
	* Customization is mandatory.
	* During data pipe runs, this method is invoked first. Add custom code as required, for example to verify that the 
	* OAuth token has not expired.
	* @param done(err) - callback funtion to be invoked after processing is complete
	* @param pipe - data pipe configuration
	* @param pipeRunLog - a dedicated logger instance that is only available during data pipe runs	
	*/
	this.doConnectStep = function( done, pipeRunStep, pipeRunStats, pipeRunLog, pipe, pipeRunner ){

		// slack access tokens don't expire (https://api.slack.com/docs/oauth), hence no refresh is required

		// initialize slack API
		initializeSlackAPI(pipe, function (err) {

			return done(err);

		});

	}; // doConnectStep

	/*
	 * Customization is mandatory!
	 * Implement the code logic to fetch data from the source, optionally enrich it and store it in Cloudant.
	 * @param dataSet - dataSet.name contains the data set name that was (directly or indirectly) selected by the user
	 * @param done(err) - callback funtion to be invoked after processing is complete
	 * @param pipe - data pipe configuration
	 * @param pipeRunLog - a dedicated logger instance that is only available during data pipe runs
	 */
	this.fetchRecords = function( dataSet, pushRecordFn, done, pipeRunStep, pipeRunStats, pipeRunLog, pipe, pipeRunner ){

		// The data set is typically selected by the user in the "Filter Data" panel during the pipe configuration step
		// dataSet: {name: 'data set name'}. However, if you enabled the ALL option (see get Tables) and it was selected, 
		// the fetchRecords function is invoked asynchronously once for each data set.

		// Bunyan logging - https://github.com/trentm/node-bunyan
		// The log file is attached to the pipe run document, which is stored in the Cloudant repository database named pipes_db.
		// To enable debug logging, set environment variable DEBUG to '*'' or 'to sdp-pipe-run' (without the quotes).
		pipeRunLog.info('Fetching messages for channel "' + dataSet.label + '" (' + dataSet.name + ') from slack.com.');

		
		var slackApiParameters = {								// see https://api.slack.com/methods/channels.history
									channel: dataSet.name,
								    count: 1000,
								    latest: 0,
								    inclusive: 1				// include messages with the same timestamp -- this produces duplicates (note 1) but assures that no messages are lost 
								 },
			hasMoreMessages = false,
			messageCount = 0,
			lastMessageJSON = JSON.stringify({}),
			keepSystemMessages = true;

		async.doWhilst(
						function(callback) {

							// fetch channel history (https://api.slack.com/methods/channels.history)
							slack.api('channels.history', 
								      slackApiParameters,
									  function(err, response){

									  		//pipeRunLog.debug(' Slack channels.history request parameters: ');
											//pipeRunLog.debug(' ' + util.inspect(slackApiParameters,1));
											//pipeRunLog.debug(' Slack response for channels.history request: ');					
											//pipeRunLog.debug(' ' + util.inspect(response,3));

											if(err) {
												pipeRunLog.error('Error fetching messages for Slack channel "' + slackApiParameters.channel + '": ' + err);
												pipeRunLog.error('FFDC: Slack channels.history request parameters: ');
												pipeRunLog.error(' ' + util.inspect(slackApiParameters,1));
												pipeRunLog.error('FFDC: Slack response for channels.history request: ');					
												pipeRunLog.error(' ' + util.inspect(response,3));							
												return callback(err); 
											}

											if((!response) || (! response.ok)) {
												pipeRunLog.error('Error fetching messages for Slack channel "' + slackApiParameters.channel + '": ');
												pipeRunLog.error('FFDC: Slack channels.history request parameters: ');
												pipeRunLog.error(' ' + util.inspect(slackApiParameters,1));
												pipeRunLog.error('FFDC: Slack response for channels.history request: ');		
												pipeRunLog.error(' ' + util.inspect(response,3));							
												return callback('Response ok status is false.');	
											}

											//  The results of a data pipe run are persisted in Cloudant by invoking pushRecordFn, passing a single record
											//    {...} or multiple records [{...}].
											//         One Cloudant database is created for each data set and named using the following algorithm:
											//         getTablePrefix() + dataSet.name. 
											//         The total number of records is automatically calculated if this function is invoked multiple times.
											
											_.forEach(response.messages, function(message) {

												if(JSON.stringify(message) !== lastMessageJSON) {	// see note 1
													
												   if((! message.hasOwnProperty('subtype')) || (keepSystemMessages)) {   // system issued messages contain a subtype property

														// 
														// Save record in Cloudant; parameter: pass a single record or a set of records to be persisted
														//             
														pushRecordFn({
																		channel: {
																			       id: slackApiParameters.channel,
																			       name: dataSet.label
																			   },
																		message: message
																	 });

														lastMessageJSON = JSON.stringify(message);
														messageCount++;
													}
													else {
														pipeRunLog.debug('Skipping system message in Slack channel ' + slackApiParameters.channel + '.');
													}
												}												
											});

											hasMoreMessages = response.has_more;

											if((hasMoreMessages) && (response.messages.length > 0)) {
												slackApiParameters.latest = response.messages[response.messages.length - 1].ts;		
											}	

											// From the API doc:
											// The is_limited boolean property is only included for free teams that have reached the free message limit. 
											// If true, there are messages before the current result set, but they are beyond the message limit.
											// Sample response { ok: true, messages: [], has_more: false, is_limited: true }							
											if(response.is_limited) {
												return callback(null, {statusMessage:'The free plan message limit was enforced by Slack. Only some or no messages could be fetched. See https://slack.com/pricing for details.'});
											}

											// proceed with test function execution
											return callback();

									  } // function(err,
							); // slack.api('channels.history'													
						}, // fetch records function
						function() {						
							// keep running until there are no more messages to fetch
							if(hasMoreMessages === true) {
							  pipeRunLog.debug('There are more results to be fetched for API call channels.history in channel "' + slackApiParameters.channel + '"');
							}
							return (hasMoreMessages === true);
						}, // test condition function
						function(err, info) {

							// doWhilst callback function is invoked after test function returns false (aka all messages have been fetched)

							if(err) {
								pipeRunLog.error('Error fetching messages for Slack channel "' + dataSet.label + '" (' + dataSet.name + '): ' + err);
								return done({errorStatus: 'Error fetching messages for Slack channel "' + dataSet.label + '" (' + dataSet.name + '): ' + err + '. Inspect data pipe run log for details.'});	
							}

							// info data structure:
							// {
							//   statusMessage: <string>
							//   
							// }

							if(info && info.statusMessage) {
								pipeRunLog.info('Fetched ' + messageCount + ' messages from Slack channel "' + dataSet.label + '" (' + dataSet.name + '): ' + info.statusMessage);
								// display status message
								pipeRunLog.info('Additional status information: ' + info.statusMessage);
								// Invoke done callback to indicate that data set dataSet has been processed. 
								return done({infoStatus: info.statusMessage}); // processing completed successfully. the value of the property infoStatus is displayed to the end user in the monitoring view
							}

							pipeRunLog.info('Fetched ' + messageCount + ' messages from Slack channel "' + dataSet.label + '" (' + dataSet.name + ').');
							return done();	// no parameter; processing completed successfully. no status message text is displayed to the end user in the monitoring view 	
							
						} // doWhilst callback function
		);

	}; // fetchRecords

	/*
	 * Customization is not needed.
	 */
	this.getTablePrefix = function(){
		// The prefix is used to generate names for the Cloudant staging databases that hold your data. The recommended
		// value is the connector ID to assure uniqueness.
		return connectorInfo.id;
	};

	/*
	 *  --------------------------------------------------------------------------------------------------------------------
	 *   Internal helper methods
	 *  --------------------------------------------------------------------------------------------------------------------
	 */

    /**
     * Instantiate slack API wrapper
     * @param {Object} pipe - data pipe configuration
     */
	var initializeSlackAPI  = function(pipe, done) {

		// API interface is data pipe configuration specific
		slack = null;

		if((pipe) && (pipe.oAuth) && (pipe.oAuth.accessToken)){
			// instantiate Slack API library
			slack = new Slack(pipe.oAuth.accessToken);

			// Verify authentication information
			slack.api('auth.test', function(err, response){

				if(err) {
					globalLog.error('The Slack API library cannot be initialized. Call to https://slack.com/api/auth.test returned: ' + err);
					return done('The Slack API library cannot be initialized. Call to https://slack.com/api/auth.test returned: ' + err);
				}

				if((!response) || (! response.ok)) {
					globalLog.error('The Slack API library cannot be initialized. Call to https://slack.com/api/auth.test returned an unexpected result.');
					globalLog.error('FFDC: Slack respose: ' + util.inspect(response,3));
					return done('The Slack API library cannot be initialized. Check the log file for details.');					
				}

				return done();
			});
		}
		else {
			slack = null;
			return done('The Slack API library cannot be initialized because the OAuth token is missing in the data pipe configuration.');
		}
	}; // initializeSlackAPI

} 

util.inherits(oAuthSlackConnector, connectorExt);

module.exports = new oAuthSlackConnector();